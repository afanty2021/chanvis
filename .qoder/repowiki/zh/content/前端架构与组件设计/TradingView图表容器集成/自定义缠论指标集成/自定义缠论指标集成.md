# 自定义缠论指标集成

<cite>
**本文档引用的文件**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue)
- [conf.py](file://comm/conf.py)
- [chanapi.py](file://api/chanapi.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心缠论指标技术细节](#核心缠论指标技术细节)
3. [metainfo配置项详解](#metainfo配置项详解)
4. [constructor异步数据获取流程](#constructor异步数据获取流程)
5. [main函数数据匹配与输出](#main函数数据匹配与输出)
6. [时间戳对齐与时区处理](#时间戳对齐与时区处理)

## 引言
本项目是一个基于TradingView本地SDK的可视化前后端代码系统，专为缠论量化研究设计。系统通过前端Vue框架与后端Python Flask服务的结合，实现了自定义缠论指标的可视化展示。核心功能包括NMA、NMM、NMC、NMS、NMC2、NDX等缠论指标的计算与绘制，这些指标通过自定义的`custom_indicators_getter`机制集成到TradingView图表中。前端通过axios异步请求从本地API获取后端计算的指标数据，并在图表上进行渲染。系统架构前后端分离，前端负责可视化，后端提供数据接口，实现了灵活的缠论分析功能。

**Section sources**
- [README.md](file://README.md#L1-L153)

## 核心缠论指标技术细节
在`ChanContainer.vue`文件中，通过`custom_indicators_getter`函数定义了一系列自定义缠论指标，包括NMA、NMM、NMC、NMS、NMC2、NDX等。每个指标都包含`metainfo`配置和`constructor`构造函数。`metainfo`定义了指标的元信息，如名称、描述、绘图类型和样式。`constructor`中的`init`方法负责在初始化时通过axios异步请求`/api/get_ocean_ind`接口获取后端计算的指标数据，并将数据存储在`this.fakeData`中。`main`方法则在每次图表更新时被调用，根据当前K线的时间戳从`fakeData`中匹配并返回相应的指标值。这些指标数据由后端Python服务计算并存储在MongoDB中，前端通过HTTP请求获取，实现了前后端的数据分离与高效集成。

**Section sources**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue#L144-L1570)

## metainfo配置项详解
每个缠论指标的`metainfo`配置项定义了其在图表中的显示属性。`_metainfoVersion`指定元信息版本，`id`为指标唯一标识符。`is_price_study`决定指标是否在主价格窗口显示，如NMA为`true`，而NMM为`false`。`plots`数组定义了绘图类型，如`'line'`表示线形图，`'hline'`表示水平线。`defaults.styles`配置了线条样式，包括`linestyle`（线型）、`linewidth`（线宽）、`plottype`（绘图类型代码）、`transparency`（透明度）和`color`（颜色）。例如，NMA指标的`plot_0`使用黄色（`#FFFF00`）实线，透明度为10；NDX指标的`plot_1`使用黄色（`#FFFF00`）虚线，透明度为50。`precision`设置数值精度，通常为2位小数。这些配置共同决定了指标在图表中的视觉表现。

**Section sources**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue#L150-L800)

## constructor异步数据获取流程
`constructor`中的`init`方法实现了异步获取后端指标数据的完整流程。首先，通过`tvWidget.activeChart().symbol()`和`resolution()`获取当前交易对和时间周期。然后，使用axios发起GET请求到`http://127.0.0.1:8421/api/get_ocean_ind`，参数包括`resolution`、`symbol`和`ind`（指标类型，如'nma'、'nmm'等）。请求成功后，检查响应状态`res.data.status`是否为'ok'，若成功则将`res.data.data`赋值给`this.fakeData`。此数据是一个以时间戳为键的对象，存储了每个时间点的指标值。数据获取是异步的，不影响图表的初始化流程。`init`方法还初始化了计数器`count`和指标值变量（如`this.nma`），并设置了PineJS上下文，为`main`函数的执行做好准备。

**Section sources**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue#L204-L236)

## main函数数据匹配与输出
`main`函数是指标计算的核心，负责在每次图表更新时返回当前K线对应的指标值。函数首先递增`count`计数器，并通过`this._context['symbol']['time'] / 1000`获取当前K线的时间戳（单位为秒）。当`count > 10`且`fakeData`存在时，检查`fakeData`对象是否包含该时间戳的键（`hasOwnProperty(t)`）。如果存在，则从`fakeData[t]`中提取相应的指标值，例如NMA指标提取`nma`和`fast_nma`，NMC指标提取`nmc`和`nmc_sd`。最后，`main`函数返回一个数组，包含所有需要绘制的值。例如，NMA返回`[this.nma, this.fast_nma]`，NDX返回`[this.ndx, 50, 0, -50]`。这些值与`metainfo.plots`的定义一一对应，驱动图表绘制多条曲线。

**Section sources**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue#L238-L264)

## 时间戳对齐与时区处理
系统通过`symbol['time']/1000`的转换机制解决了时间戳对齐和时区偏移问题。TradingView前端传递的时间戳是毫秒级的，而后端MongoDB存储和计算使用的是秒级时间戳。因此，除以1000将毫秒转换为秒，确保了前后端时间戳的一致性。该时间戳代表K线的开始时间，用于精确匹配后端存储的指标数据。虽然代码注释中提到“8小时的时区问题”，但实际代码并未进行时区偏移修正（相关代码被注释掉），而是直接使用UTC时间戳进行匹配。这种设计依赖于后端在计算指标时已使用统一的UTC时间，从而避免了前端复杂的时区处理，保证了数据匹配的准确性和效率。

**Section sources**
- [ChanContainer.vue](file://ui/src/components/ChanContainer.vue#L241-L242)